I’ve been thinking of writing such an article for a while. A few weeks ago, I got contacted by people who wanted
to know more about my experience with [luminance](https://github.com/phaazon/luminance) so that they can have
more hindsight about their own APIs and products.

I came to the realization that I could write a blog entry to discuss designs decisions and, at some extent, what
a good design entails. Keep in mind it’s only personal thoughts and that I won’t talk for someone else.

# Elegancy

I love mathematics because they’re elegant. They solve problems with very nice abstractions. In mathematics, we
have a concept that is – astonishingly – not very spread and barely known outside of math geeks circles: *free*
objects.

The concept of *free* is a bit overwhelming at first, because people are used to put labels and examples on
everything. For instance, if I say that an object is *free*, you might already have associated some kind of
*lock* to that object, so that you can get why it’s *free*. But we’re mistaken. We don’t need *locks* to
define what *free* implies. In mathematic, a *free* object is an object that can’t be defined in terms of others.
It’s a bit like a *core* object. It’s *free* because it can be there, no matter what other objects are around. It
has no dependency, it doesn’t require no other interaction. You can also say that such an object is *free* of
extra features that wouldn’t be linked to its nature.

For instance, in vector spaces, `<(1,0),(0,1)>` is a free object in **ℝ²** because you it can live on by itself.
With that object, you can represent any `(x,y)` by creating a linear combination `x * (1,0) + y * (0,1)`.

Another famous example – more Haskellish – is the list being a *free* *monoid*. A *monoid* requires a neutral
element – `mempty` in Haskell – and an associative binary function – `mappend` or `(<>)` in Haskell – for which
the following laws stand:

    mempty <> a = a <> mempty = a
    a <> b <> c = a <> (b <> c) = (a <> b) <> c

A list is a *free* monoid because whatever the type of the list, you have a monoid. It doesn’t need to know the
embedded type to be a monoid. So it’s *free*. `[Int]` is a monoid; `String` is a monoid and `[Tree String]` is
also a monoid.
